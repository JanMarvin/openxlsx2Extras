% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/read_xlsx_ext.R
\name{read_xlsx_ext}
\alias{read_xlsx_ext}
\title{Create a data frame from a Workbook (with extra features)}
\usage{
read_xlsx_ext(file, ..., repair = "unique")
}
\arguments{
\item{file}{An xlsx file, \link[openxlsx2]{wbWorkbook} object or URL to xlsx file.}

\item{...}{
  Arguments passed on to \code{\link[openxlsx2:wb_to_df]{openxlsx2::read_xlsx}}
  \describe{
    \item{\code{sheet}}{Either sheet name or index. When missing the first sheet in the workbook is selected.}
    \item{\code{start_row}}{first row to begin looking for data.}
    \item{\code{start_col}}{first column to begin looking for data.}
    \item{\code{row_names}}{If \code{TRUE}, the first col of data will be used as row names.}
    \item{\code{col_names}}{If \code{TRUE}, the first row of data will be used as column names.}
    \item{\code{skip_empty_rows}}{If \code{TRUE}, empty rows are skipped.}
    \item{\code{skip_empty_cols}}{If \code{TRUE}, empty columns are skipped.}
    \item{\code{rows}}{A numeric vector specifying which rows in the xlsx file to read.
If \code{NULL}, all rows are read.}
    \item{\code{cols}}{A numeric vector specifying which columns in the xlsx file to read.
If \code{NULL}, all columns are read.}
    \item{\code{detect_dates}}{If \code{TRUE}, attempt to recognize dates and perform conversion.}
    \item{\code{na.strings}}{A character vector of strings which are to be interpreted as \code{NA}.
Blank cells will be returned as \code{NA}.}
    \item{\code{na.numbers}}{A numeric vector of digits which are to be interpreted as \code{NA}.
Blank cells will be returned as \code{NA}.}
    \item{\code{fill_merged_cells}}{If \code{TRUE}, the value in a merged cell is given to all cells within the merge.}
    \item{\code{named_region}}{Character string with a \code{named_region} (defined name or table).
If no sheet is selected, the first appearance will be selected. See \code{\link[openxlsx2:wb_get_named_regions]{wb_get_named_regions()}}}
    \item{\code{check_names}}{If \code{TRUE} then the names of the variables in the data frame are checked to ensure that they are syntactically valid variable names.}
    \item{\code{show_hyperlinks}}{If \code{TRUE} instead of the displayed text, hyperlink targets are shown.}
  }}

\item{repair}{Either a string or a function. If a string, it must be one of
\code{"check_unique"}, \code{"minimal"}, \code{"unique"}, \code{"universal"}, \code{"unique_quiet"},
or \code{"universal_quiet"}. If a function, it is invoked with a vector of
minimal names and must return minimal names, otherwise an error is thrown.
\itemize{
\item Minimal names are never \code{NULL} or \code{NA}. When an element doesn't
have a name, its minimal name is an empty string.
\item Unique names are unique. A suffix is appended to duplicate
names to make them unique.
\item Universal names are unique and syntactic, meaning that you can
safely use the names as variables without causing a syntax
error.
}

The \code{"check_unique"} option doesn't perform any name repair.
Instead, an error is raised if the names don't suit the
\code{"unique"} criteria.

The options \code{"unique_quiet"} and \code{"universal_quiet"} are here to help the
user who calls this function indirectly, via another function which exposes
\code{repair} but not \code{quiet}. Specifying \code{repair = "unique_quiet"} is like
specifying \verb{repair = "unique", quiet = TRUE}. When the \code{"*_quiet"} options
are used, any setting of \code{quiet} is silently overridden.}
}
\description{
\ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#experimental}{\figure{lifecycle-experimental.svg}{options: alt='[Experimental]'}}}{\strong{[Experimental]}}

\code{\link[=read_xlsx_ext]{read_xlsx_ext()}} uses \code{\link[openxlsx2:wb_to_df]{openxlsx2::read_xlsx()}} but allows use of a name
repair argument (\code{"unique"} by default) to avoid blank \code{""} or \code{NA} values
for column names.
}
